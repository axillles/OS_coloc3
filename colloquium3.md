# Третий коллоквиум: Поведенческие шаблоны проектирования (четный вариант)

Этот документ посвящен четному варианту третьего коллоквиума, в котором рассматриваются поведенческие шаблоны проектирования **Состояние**, **Посредник** и **Наблюдатель**, их определения, примеры использования и анализ с точки зрения инкапсуляции, принципа «разделяй и властвуй» и ортогональных стратегий. Также обсуждается понятие дизайна программного обеспечения и влияние многопоточности.

## Missouri: [Перевод на русский]

## 1. Поведенческие шаблоны проектирования

Поведенческие шаблоны проектирования сосредоточены на взаимодействии объектов, улучшая гибкость и повторное использование кода за счет оптимизации их коммуникации. Ниже приведены определения шаблонов **Состояние**, **Посредник** и **Наблюдатель**, не менее трех примеров использования для каждого в формате «проблема/решение», а также их анализ с учетом принципов дизайна и многопоточности.

### 1.1 Шаблон Состояние

**Определение**: Шаблон Состояние позволяет объекту изменять свое поведение при изменении внутреннего состояния, создавая впечатление, что объект меняет свой класс. Поведение, зависящее от состояния, инкапсулируется в отдельных классах, а управление передается текущему объекту состояния.

**Примеры «проблема/решение»**:

1. **Проблема**: Торговый автомат должен выполнять разные действия (например, выдача товара, прием монет, отклонение действий) в зависимости от состояния (например, ожидание, монета вставлена, товар распродан). Кодирование переходов состояний в одном классе приводит к сложным условным конструкциям и плохой поддерживаемости.  
   **Решение**: Использовать шаблон Состояние для определения состояний (`IdleState`, `HasCoinState`, `SoldOutState`) как отдельных классов. Торговый автомат делегирует действия текущему состоянию, которое инкапсулирует поведение, специфичное для этого состояния, упрощая добавление новых состояний.

2. **Проблема**: Соединение TCP должно вести себя по-разному в зависимости от состояния (например, прослушивание, установлено, закрыто), каждое из которых имеет уникальные правила обработки событий. Смешивание логики состояний в одном классе нарушает принцип единственной ответственности.  
   **Решение**: Реализовать состояния как классы (`TCPListen`, `TCPEstablished`, `TCPClosed`), наследующиеся от интерфейса `TCPState`. Класс `TCPConnection` делегирует события текущему состоянию, обеспечивая чистые переходы и инкапсуляцию поведения.

3. **Проблема**: Поведение игрового персонажа (например, ходьба, бег, прыжки) меняется в зависимости от состояния здоровья (здоров, ранен, критическое состояние). Управление этим в одном классе приводит к запутанному коду.  
   **Решение**: Использовать шаблон Состояние для определения классов `HealthyState`, `InjuredState` и `CriticalState`. Персонаж делегирует действия текущему состоянию, обеспечивая инкапсуляцию и простоту модификации.

**Инкапсуляция**: Шаблон Состояние инкапсулирует поведение, зависящее от состояния, в отдельных классах, скрывая детали реализации от контекста (например, торгового автомата или соединения TCP). Контекст взаимодействует с состояниями через общий интерфейс, поддерживая сокрытие информации.

**Разделяй и властвуй**: Шаблон разделяет задачу управления состоянием на меньшие, управляемые единицы, где каждый класс состояния отвечает за свое поведение, снижая сложность контекстного класса.

**Ортогональные стратегии**: Шаблон Состояние ортогонален, так как поведение состояния (например, выдача товара) независимо от переходов между состояниями (например, переход от `HasCoin` к `SoldOut`). Это позволяет добавлять новые состояния без изменения контекста или других состояний.

**Многопоточность**: В многопоточной среде переходы между состояниями должны быть потокобезопасными. Например, если несколько потоков вызывают действия на торговом автомате, одновременные изменения состояния могут привести к гонкам данных. Решения:
- Использование мьютекса для синхронизации доступа к текущему состоянию.
- Обеспечение атомарных переходов состояний с помощью `std::atomic` для указателя состояния.
- Избежание общего изменяемого состояния, делая объекты состояний неизменяемыми или локальными для потока.

### 1.2 Шаблон Посредник

**Определение**: Шаблон Посредник определяет объект, который инкапсулирует взаимодействие множества объектов, способствуя слабой связанности, предотвращая прямое взаимодействие. Он централизует логику коммуникации в посреднике.

**Примеры «проблема/решение»**:

1. **Проблема**: В чат-приложении пользователи отправляют сообщения друг другу напрямую, что приводит к сильной связанности и сложному управлению зависимостями при росте числа пользователей.  
   **Решение**: Использовать посредник `ChatRoom` для маршрутизации сообщений. Пользователи отправляют сообщения посреднику, который пересылает их нужным получателям, снижая связанность.

2. **Проблема**: В фреймворке GUI компоненты интерфейса (кнопки, текстовые поля, выпадающие списки) должны взаимодействовать (например, активация кнопки при заполнении поля). Прямое взаимодействие между компонентами усложняет поддержку.  
   **Решение**: Реализовать `DialogMediator`, который координирует взаимодействия. Компоненты уведомляют посредника об изменениях, а он обновляет другие компоненты, обеспечивая слабую связанность.

3. **Проблема**: В системе управления воздушным движением самолеты напрямую обмениваются данными для предотвращения столкновений, что приводит к сложным парным взаимодействиям.  
   **Решение**: Использовать посредник `ControlTower` для управления коммуникацией. Самолеты сообщают свои позиции вышке, которая выдает инструкции, упрощая взаимодействия и централизуя логику.

**Инкапсуляция**: Посредник инкапсулирует логику взаимодействия, скрывая детали коммуникации от объектов. Каждый объект знает только о посреднике, а не о других объектах.

**Разделяй и властвуй**: Шаблон разделяет задачу взаимодействия объектов на две части: логику координации посредника и индивидуальное поведение объектов. Это упрощает систему за счет централизации коммуникации.

**Ортогональные стратегии**: Шаблон Посредник разделяет логику взаимодействия (как объекты общаются) и внутреннее поведение объектов (что они делают). Эта ортогональность позволяет изменять логику посредника (например, добавлять новые правила взаимодействия) без модификации объектов.

**Многопоточность**: В многопоточных системах посредник может стать узким местом при одновременном взаимодействии объектов. Решения:
- Синхронизация доступа к посреднику с помощью мьютекса или потокобезопасных структур данных.
- Использование асинхронных сообщений (например, потокобезопасной очереди) для обработки взаимодействий.
- Обеспечение потокобезопасности внутреннего состояния посредника для предотвращения гонок данных.

### 1.3 Шаблон Наблюдатель

**Определение**: Шаблон Наблюдатель определяет зависимость «один-ко-многим» между объектами, так что при изменении состояния одного объекта (субъекта) все зависимые объекты (наблюдатели) автоматически уведомляются и обновляются. Он способствует слабой связанности между субъектом и наблюдателями.

**Примеры «проблема/решение»**:

1. **Проблема**: В приложении фондового рынка несколько дисплеев (таблица, график, мобильное приложение) должны обновляться при изменении цен акций. Плотная связь дисплеев с источником данных усложняет добавление новых дисплеев.  
   **Решение**: Использовать шаблон Наблюдатель. Субъект `StockData` уведомляет зарегистрированных наблюдателей `Display` при изменении цен. Дисплеи реализуют метод `update`, позволяя добавлять новые дисплеи без модификации субъекта.

2. **Проблема**: На метеостанции датчики сообщают об изменениях температуры, и различные панели должны отображать эти обновления. Прямая связь между датчиками и панелями приводит к негибкому коду.  
   **Решение**: Реализовать датчики как субъекты, а панели как наблюдателей. При изменении состояния датчика он уведомляет все зарегистрированные панели, которые обновляют свои дисплеи независимо.

3. **Проблема (пример Qt)**: В приложении на Qt изменение значения ползунка должно обновлять метку и индикатор прогресса. Жесткое кодирование связей между виджетами увеличивает сложность.  
   **Решение**: Использовать механизм сигналов и слотов Qt, вариант шаблона Наблюдатель. Ползунок испускает сигнал `valueChanged(int)`, а метка и индикатор прогресса подключают свои слоты `setText` и `setValue`. Пример на Qt:

```cpp
#include <QApplication>
#include <QSlider>
#include <QLabel>
#include <QProgressBar>
#include <QVBoxLayout>
#include <QWidget>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    QWidget window;
    QVBoxLayout layout(&window);

    QSlider slider(Qt::Horizontal);
    QLabel label("Значение: 0");
    QProgressBar progress;

    layout.addWidget(&slider);
    layout.addWidget(&label);
    layout.addWidget(&progress);

    QObject::connect(&slider, &QSlider::valueChanged, &label, [&](int value) {
        label.setText(QString("Значение: %1").arg(value));
    });
    QObject::connect(&slider, &QSlider::valueChanged, &progress, &QProgressBar::setValue);

    window.show();
    return app.exec();
}
```

**Инкапсуляция**: Шаблон Наблюдатель инкапсулирует состояние субъекта и логику уведомлений, скрывая от наблюдателей детали распространения обновлений. Наблюдатели реализуют только интерфейс обновления, не зная о других наблюдателях или внутренностях субъекта.

**Разделяй и властвуй**: Шаблон разделяет задачу на управление состоянием субъекта и логику обновления наблюдателей. Это разделение позволяет независимо разрабатывать субъекты и наблюдателей.

**Ортогональные стратегии**: Механизм уведомлений (например, передача данных или их запрос) ортогонален поведению наблюдателей. Субъект может передавать данные наблюдателям или позволять им запрашивать их, не влияя на логику наблюдателей.

**Многопоточность**: Уведомление наблюдателей в многопоточной среде может вызывать проблемы:
- Синхронизация доступа к списку наблюдателей для предотвращения одновременного изменения (например, добавления/удаления наблюдателей во время уведомления).
- Использование потокобезопасного механизма уведомлений, например, очереди или механизма сигналов и слотов Qt.
- В Qt сигналы и слоты автоматически обрабатывают потокобезопасность при нахождении объектов в разных потоках, используя отложенные соединения.

## 2. Дизайн программного обеспечения

**Определение**: Дизайн программного обеспечения — это процесс определения структуры, компонентов, интерфейсов и взаимодействий программной системы для удовлетворения заданных требований. Он фокусируется на высокоуровневой организации кода (например, модули, классы, шаблоны) и связывает требования с реализацией. В отличие от архитектуры, которая касается системных аспектов (например, масштабируемость, развертывание), дизайн сосредоточен на внутренней структуре компонентов.

**Ключевые аспекты**:
- **Модульность**: Разделение системы на независимые, связные модули с четко определенными интерфейсами.
- **Абстракция**: Скрытие деталей реализации за интерфейсами для упрощения взаимодействий.
- **Повторное использование**: Проектирование компонентов, которые можно использовать в разных контекстах.
- **Поддерживаемость**: Обеспечение простоты модификации и расширения системы.

**Пример**: В веб-приложении дизайн включает определение классов для интерфейса пользователя, бизнес-логики и слоев доступа к данным, выбор шаблонов, таких как MVC, и указание способов взаимодействия компонентов (например, использование Наблюдателя для обновления интерфейса).

**Влияние многопоточности на дизайн**:
- **Потокобезопасность**: Дизайн должен учитывать одновременный доступ к общим ресурсам. Например, шаблон Состояние требует синхронизированных переходов состояний, а Посредник — потокобезопасных каналов связи.
- **Производительность**: Многопоточность добавляет накладные расходы (например, блокировки, переключение контекста). Дизайн должен минимизировать конфликты, например, используя структуры данных без блокировок или асинхронные уведомления Наблюдателя.
- **Сложность**: Многопоточность усложняет дизайн, требуя примитивов синхронизации (например, мьютексы, семафоры) и тщательной обработки гонок данных. Например, цикл уведомлений Наблюдателя должен быть потокобезопасным.
- **Масштабируемость**: Дизайн должен поддерживать параллельное выполнение. Например, шаблон Посредник может использовать пул потоков для обработки взаимодействий, улучшая отзывчивость.
- **Инструменты и фреймворки**: Фреймворки, такие как Qt, упрощают многопоточный дизайн, предоставляя потокобезопасные механизмы (например, сигналы и слоты), снижая необходимость ручной синхронизации.

**Пример влияния**: В приложении на Qt, использующем шаблон Наблюдатель, дизайн использует механизм сигналов и слотов Qt для прозрачной обработки многопоточности. Сигналы, испускаемые из одного потока, безопасно доставляются в слоты другого потока через отложенные соединения, упрощая дизайн по сравнению с ручным управлением мьютексами.

## Заключение

Шаблоны **Состояние**, **Посредник** и **Наблюдатель** решают поведенческие задачи, инкапсулируя поведение, разделяя обязанности и обеспечивая ортогональные стратегии. Они соответствуют принципу «разделяй и властвуй», разделяя задачи (например, логику состояний, взаимодействий, уведомлений) и способствуя слабой связанности. Многопоточность добавляет сложности, такие как гонки данных и накладные расходы, требуя тщательной синхронизации и потокобезопасных дизайнов. Дизайн программного обеспечения обеспечивает эффективное применение этих шаблонов для создания модульных, поддерживаемых систем, а многопоточность влияет на выбор механизмов синхронизации и использование фреймворков (например, сигналов и слотов Qt).